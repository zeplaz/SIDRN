k(x;h)= ((2PIE)^(-d/2))/hd


  double pixel_feture_xy_RGB



}

static std::timed_mutex stat_timed_mux_a1;

void operator() ()const
{
  td::unique_lock lock_1timed(stat_timed_mux_a1,milsecontimedelay)
      if(lock_1timed)
        {

        }
      else
        {

        }
}

std::timed_mutex classofobmutime::stat_timed_mux_a1;

std::mutex

//base_agent_0_03.h
#include <utility>

 <tuple>
 auto test_touple = make_tuple(int,*thread_pools,feturespace,bool)

 auto test_touple2 = make_tuple(int,feturespace,bool)


int id_num;
thread_pool* pool ;
bool active;

std::tie(id_num,pool,active) = test_touple2;


std::tie(std::ignore,)

auto tubp3= tuple_cat(test_touple2,test_touple);
std::apply(fucntion,tubp3_asagumn;


//make_from_tuple
//supports std::get<>()  && std::tuple_size);

auto objecfromtouple make_from_tuple<classname>(tupleororotherobj);



template<size_t type_pool_size>
class base_agent_0_03
{
void Thead_pool_stack(char (&thread_pool)[type_pool_size])
{
 for ( size_t i = 0, i<type_pool_size; i++)
 {
 thread_pool[i]= new thread;...

 }
}
struct task_array[agent_dakable&]

  char* m
} ;

class thread_pools_aloctr

template<class pooltype>

{
struct threadpool_agent
{
 w_chat[thread*];

}


{
 w_char_t [th]
}

struct theadpool_Render{}


static char* creat_pool(char pooltype)
{

}

};

std::tuple<int,>
