

transistors-> digtial logic gates
82mm 	Zagan 82 mm moździerz wz 37.jpg 	82mm 	 Albania
logic gates -> inteutison setup
insturtion set->progam langs
prg->ap.
Export
Former Iraqi YW701 command vehicle at the Puckkapunyal Military Museum

    Type YW531C or Type 81 (1982) - Export version of the 531 series with German Deutz engine KHD BF8L of 320 hp (240 kW). The machine gunner's position front right was deleted.
        Type YW531D - Modified version with only 1 instead of 2 firing ports on the left side.
        Type YW531E - As per YW531D but with one additional radio Type 892.
    Type YW701 - Export version of the Type WZ701 command post vehicle. Based on the Type YW531C and equipped with a commander's cupola with Type 54 machine gun.
    Type YW750 - Export version of the Type WZ750 armoured ambulance. Based on the Type YW531C and equipped with a commander's cupola with Type 54 machine gun.
    Type YW304 - Self-propelled 82 mm mortar with 120 rounds, based on the Type YW531C.
    Type YW381 - Self-propelled 120 mm mortar with 50 rounds, based on the Type YW531C.
    Type YW531H (Type 85)
120-PM-43 mortar
130 mm towed field gun M1954 (M-46)
Mass	7.7 t (16,975 lbs)
Length	11.73 m (38 ft 6 in)
Barrel length	6.76 m (22 ft 2 in) L/52
Width	2.45 m (8 ft)
Height	2.55 m (8 ft 4 in)
Crew	8
Shell	separate-loading charge and projectile
Caliber	130 mm (5.1 in)
Breech	Horizontal sliding-wedge
Recoil	hydro-pneumatic
Carriage	Split-trail
Elevation	-2.5° to 45°
Traverse	50°
Rate of fire	6 (normal)
8 (burst)
5 (sustained)
Muzzle velocity	930 m/s (3,051 ft/s)
Maximum firing range	27.5 km (17 mi) (unassisted) 38 km (23.61 mi) (assisted)





using cuv_precision = double;

struct curve_plot_paramterz
{
cuv_precision = _max_range;
cuv_precision _min_range;
cuv_precision _interval;

};


unction inRange(x, a, b) { return x*x - (a+b)*x + a*b <= 0 }﻿

template <typename TFunction>
auto plot_curve_ray(const covr_parmz co_plot_pram, TFunction && func)
{

  if (co_plot_pram._min_range >= co_plot_pram._max_range)
  { printf("error on range of curveray\n");

  }

sf::VertexArray curve(sf::PrimitiveType::LineStrip,
                     std::ceil((co_plot_pram._max_range - co_plot_pram._min_range)
                                /co_plot_pram._interval));

          for (auto x= co_plot_pram._min_range < co_plot_pram._max_range; x+=co_plot_pram._interval)
          {
          curve.append(Vertex(func(x)));
          }
}


auto new_curve = plot_curve_ray(curntpamz,[](auto x){return sf::Vector2f(x,-sin(x)); });




sf::


entty compoent syste,


116.565degrees
126.869degees
53.130
100by50
26.565
tan().... 0.5
 static struct phstics_comp_engne {

 };

 template<class shape_type>
 {

 }
class shape {
 mesh_5plane
}


 struct entity_handle
 {
      constexpr entity_handle() : index(0),counter(0){}
      constexpr entity_handle(uint32_t a_index, uint32_t a_counter)
      : index(a_index), counter(a_counter){}

      constexpr bool is_vaild() const {return !(index ==0 && counter ==0);}
      constexpr bool() const {return is_vaild();}
      constexpr uint32_t hash() const {return counter << | index;}

      uint32_t index :;
      uint32_t counter : ;
 };


struct index_entry{
value_type counter = 0;
index_type next_free = NONE;
};


value_type get_free_entry()
{
if (enty_first_free!= NONE)
{
  value_type result = enty_first_free;
  enty_first_free = enity_entriez[result].next_free;
  enity_entriez[result].next_free == USED;
  if(enty_first_free == NONE) enty_last_free = NONE;
  return result;}

enity_entriez.emplace_back();
return value_type(enity_entriez.size()-1);
}

index_type enty_first_free;
index_type enty_last_free;
std::vector<index_entry> enity_entriez;


 struct something{


  struct component_CMD
  {
  ...
  void* get_raw(entity_handle handl)
  { int i = comp_intex->get(handl);

    return i>=0? comp_storage->raw(i) : nullptr;

    index_table* comp_intex;
    component_depot* comp_storage;};

    entity_handle_manger enty_handlez_mgmt;
    std::vector<component_depot*> vec_compoenz;
    std::unorderd_map<const std::type_info*,component_depot* > entity_compoent_map;



  }
  }
 }

compoents rep capabliz.

class soldat extends base_entity()
{
   infintry_class soldat_class;
   int status;
   float x,y,h;

};

};

class cmand_pattern
{ actionResult preform();

}


class infintry_class
{
  std::string name;
  int max_status;
  dischage_wepon fire;

  equitment<>
  inventory_is cur_in
}



class AI_System {
  void update(){
    for (var compoeint in aicompoents)
    componets.updtae
  }
}
pathefinding
line_of_site

entity_factor

template<class RType, class Type = RType>
struct type_factory
{
    template<class ...Args>
    RType* operator()(Args&&... args){return new Type(std::forward<Args>(args)...);}
};

stearing_force


namespace SIDRN {
namespace shirz0_1{


class base_entity()
{

};
struct battery{

  void type(const char *s)
    {

      }
};

struct battery_factory()
{
  battery make()
  { return battery();}
};



struct M_46_130mm_M1954{
void build(const char *s)
{
}

struct M_46_130mm_M1954

}


template <class artillery_factory>
void build(artillery_factory &bateri_factory)
{
auto bateri = bateri_factory.make
}

class entity_factory
{

};

class statez_bases()
{
};


class factory_state public : statez_bases()
{

};

renderd_enity public : base_entity ()
{

};

renderd_enity_factory public :entity_factory()
{

};

movable_renderd_enity public : renderd_enity()
{

};

movable_renderd_enity_factory public : renderd_enity_factory()
{
  make_asset()
  {

  }
};





AI_agent make_AI_agent()
{

}

void send_agent_(teplated take a facotry if it is a function, )
{
reutrns a connections

}

end of entity delcrations


class



class base_agent
{};

class AI_agent public : base_agent
{

};





class type_59_MBT : public  MBT
{
virtual void draw();
vitual void move();


};



class inputstreamd_agent public : base_agent ()
{};

 }//namespaceend shirz }

// end of agent delgraionz

connection

connection factory


class ICommand
{
    public:
        virtual void Execute() = 0;
};

class Switcher
{
    private:
      std::vector<ICommand *> _commands;

    public:
        void StoreAndExecute(ICommand *command)
        {
            if (command){
                _commands.push_back(command);
                command->Execute();
            }
        }
};

class Light
{
    public:
        void TurnOn()
        {
            std::cout<<"The light is on."<<std::endl;
        }

        void TurnOff()
        {
            std::cout << "The light is off." << std::endl;
        }
};

/* The Command for turning on the light - ConcreteCommand #1 */
class FlipUpCommand : public ICommand
{
  private:
    Light *_light;

  public:
    FlipUpCommand(Light *light)
    {
        _light = light;
    }

    void Execute()
    {
        _light->TurnOn();
    }
};

/* The Command for turning off the light - ConcreteCommand #2 */
class FlipDownCommand : public ICommand
{
  private:
    Light *_light;

  public:
    FlipDownCommand(Light *light)
    {
        _light = light;
    }

    void Execute()
    {
        _light->TurnOff();
    }
};

int main()
{
    std::unique_ptr<Light> light = std::make_unique<Light>();
    std::unique_ptr<ICommand> switchOn (new FlipUpCommand(light.get()));
    std::unique_ptr<ICommand> switchDown (new FlipDownCommand(light.get()));

    std::unique_ptr<Switcher> switcher = std::make_unique<Switcher>();
    switcher->StoreAndExecute(switchOn.get());
    switcher->StoreAndExecute(switchDown.get());

    return 0;
}
